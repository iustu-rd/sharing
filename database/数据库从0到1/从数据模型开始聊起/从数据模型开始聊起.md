# 从数据模型开始聊起    
- [从数据模型开始聊起](#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B%E8%81%8A%E8%B5%B7)
  - [介绍](#%E4%BB%8B%E7%BB%8D)
  - [逻辑数据模型](#%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B)
    - [关系模型](#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B)
    - [网络模型](#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
    - [文档模型](#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B)
      - [层次模型](#%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B)
    - [图模型](#%E5%9B%BE%E6%A8%A1%E5%9E%8B)
    - [时序数据模型](#%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B)
  - [比较和关联](#%E6%AF%94%E8%BE%83%E5%92%8C%E5%85%B3%E8%81%94)
    - [关系和文档](#%E5%85%B3%E7%B3%BB%E5%92%8C%E6%96%87%E6%A1%A3)
      - [模型相关](#%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3)
      - [MySQL 和 MongoDB](#mysql-%E5%92%8C-mongodb)
    - [图和时序](#%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F)
      - [图](#%E5%9B%BE)
      - [时序](#%E6%97%B6%E5%BA%8F)
  - [总结](#%E6%80%BB%E7%BB%93)
  - [参考文献](#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)

## 介绍
**全文结构及内容大量参考《[Designing Data-Intensive Application][DDIA]》的第二章数据模型与查询语言，重新组织了一些结构，带有部分自己的看法与介绍，主要在分享时阐述与讲解。**

[DDIA]: http://dataintensive.net/

[数据模型][data_model]（Data Model）是数据特征的抽象。

数据模型这个东西可能会是软件开发中最重要的一个部分了，因为他们的影响非常的深远，不仅仅影响着软件编写方式，而且影响着我们的**解决问题的思路**

数据模型所描述的主要内容包括三个部分：
- 数据结构
- 数据操作
- 数据约束

根据其不同的应用层次，我们将数据模型**主要**分为以下[三种类型][three_type]：
- 概念数据模型

  用于描述客观世界的模型，一般要具有较强的语义表达能力，并且简单，清晰，易于用户理解。  
  常见的 [E-R模型][er_model]，面向对象模型等。

- **[逻辑数据模型](#逻辑数据模型)**
  
  对概念数据模型的进一步细化，主要是面向数据库系统的模型，是具体的 DBMS 所支持的数据模型。  
  常见的关系模型，文档模型，网络模型，图数据模型等。

- 物理数据模型
  
  数据在计算机上的物理表示的模型，描述了数据在存储介质上的组织结构。  
  DBMS 为了保证其独立性与可移植性，大部分物理数据模型的实现工作由系统自动完成，而设计者只设计索引等特殊结构。

[data_model]: https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B "数据模型 百度百科"
[three_type]: https://blog.csdn.net/gdj0001/article/details/80137496 "概念数据模型、逻辑数据模型、物理数据模型 csdn博客"
[er_model]: https://baike.baidu.com/item/E-R%E6%A8%A1%E5%9E%8B "E-R模型 百度百科"

引用书中的内容来更详细的描述层次的数据模型。

> 从应用的角度来看，多数应用使用层层叠加的数据模型构建。   
> 对于每层数据模型的关键是：**他是如何用低一层的数据模型来表示的？**
> 例如：
> 1. 作为一个应用的开发人员，你观察现实世界（里面有人员，组织货物，行为等等），并采用对象或数据结构，以及操控哪些数据结构的 API 来进行建模。那些结构通常是特定与应用程序的。
> 2. 当要存储那些数据结构时，你可以利用数据模型来表示它们，如 JSON 或 XML 文档，关系数据库中的表，或图模型。
> 3. 数据库软件的工程师选定如何以内存、磁盘或网络上的字节来表示JSON/XML/关系/图数据。这类表示形式使数据有可能以各种方式来查询，搜索，操纵和处理。
> 4. 在更低的层次上，硬件工程师已经想出了使用电流，光脉冲，磁场或者其他东西来表示字节的方法。

对于一个复杂的应用程序来说，层次会比上面描述的更加复杂，更多的中间层次会被添加在应用的内部（例如基于API的API，开发过程的）。不过基本的思想仍然是一样的：每个层都通过提供一个明确的数据模型来隐藏更低层次的复杂性。（到这里其实会让我想到软件开发过程中经常讨论到的一句名言，“计算机科学领域的任何问题都可以通过增加一个中间层来解决”，Any problem  in computer science can be solved by anther layer of indirection。这句话讲道理概括了计算机系统软件体系结构设计要点，在我们的系统中被各种各样的应用。操作系统的体系结构设计啊，web开发中的mvc啊，负载均衡的时候加的代理啊，一致性哈希解决负载不均衡的虚拟层啊，等等等等）。

所谓“数据库”，是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。你的字典是一个小数据库，图书馆也是一个数据库。而我们研发同学经常会讨论的数据库，应该是所谓的`数据库管理系统（DBMS）`。

本次分享将从一些用于数据存储和查询的通用数据模型开始聊起，包含相关数据库的应用及场景的介绍，穿插一些数据库发展的内容。


## 逻辑数据模型

**本节中的介绍内容大多摘自DDIA，主要是概念内容的概括，做了一部分结构的调整，分享时不详细介绍，但是会通过[比较和关联](#比较和关联)部分来进行探讨。**

多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，[网络模型](#网络模型)和[层次模型](#层次模型)曾是主要的选择，但[关系模型](#关系模型)随后占据了主导地位。对象数据库在20世纪80年代末和90年代初来了又去。XML数据库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续。  

随着电脑越来越强大和互联，它们开始用于日益多样化的目的。关系数据库非常成功地被推广到业务数据处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。

###  关系模型 
从数据库开始发展到现在，最著名的数据模型可能就是关系数据模型了，它基于 Edgar Codd 在1970年提出的关系模型，阐述在论文《[大型共享数据银行的关系模型][Codd_1970_A_relational_model]》中。数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。
 
起初关系模型只是一个理论性的提议，但是随着发展，关系数据库已经称霸了将近30年。  

关系数据库起源于商业数据处理，在20世纪60年代和70年代用大型计算机来执行。从今天的角度来看，那些用例显得很平常：典型的事务处理（销售或银行交易，航空公司预订，库存管理信息记录在库）和批处理（客户发票，工资单，报告）。

当时的其他数据库迫使应用程序开发人员必须考虑数据库内部的数据表示形式。关系模型致力于将上述实现细节隐藏在更简洁的接口之后。

多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，网络模型和分层模型曾是主要的选择，但关系模型随后占据了主导地位。对象数据库在20世纪80年代末和90年代初来了又去。XML数据库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续。

随着电脑越来越强大和互联，它们开始用于日益多样化的目的。关系数据库非常成功地被推广到业务数据处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。

[Codd_1970_A_relational_model]: https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf


### 网络模型

网络模型由一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的数据库商实现；它也被称为CODASYL模型。

CODASYL模型是层次模型的推广。在层次模型的树结构中，每条记录只有一个父节点；在网络模式中，每条记录可能有多个父节点。例如，“Greater Seattle Area”地区可能是一条记录，每个居住在该地区的用户都可以与之相关联。这允许对多对一和多对多的关系进行建模。  

网络模型中记录之间的链接不是外键，而更像编程语言中的指针（同时仍然存储在磁盘上）。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为**访问路径（access path）**。  

最简单的情况下，访问路径类似遍历链表：从列表头开始，每次查看一条记录，直到找到所需的记录。但在多对多关系的情况中，数条不同的路径可以到达相同的记录，网络模型的程序员必须跟踪这些不同的访问路径。

CODASYL中的查询是通过利用遍历记录列和跟随访问路径表在数据库中移动游标来执行的。如果记录有多个父结点（即多个来自其他记录的传入指针），则应用程序代码必须跟踪所有的各种关系。甚至CODASYL委员会成员也承认，这就像在n维数据空间中进行导航。

尽管手动选择访问路径够能最有效地利用20世纪70年代非常有限的硬件功能（如磁带驱动器，其搜索速度非常慢），但这使得查询和更新数据库的代码变得复杂不灵活。无论是分层还是网络模型，如果你没有所需数据的路径，就会陷入困境。你可以改变访问路径，但是必须浏览大量手写数据库查询代码，并重写来处理新的访问路径。更改应用程序的数据模型是很难的。

### 文档模型

搜索数据模型几乎没有提到文档模型的说法，书中将这种基于 **JSON** 或 **XML** 等文档状数据格式存储的方式称之为文档模式。

它提供了更多的架构灵活性。文档数据库有时称为**无模式（schemaless）**，但其实代码通常假定了某种结构————即存在隐式模式，但不由数据库强制执行。一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）。


#### 层次模型

在多对多的关系和连接已常规用在关系数据库时，文档数据库和NoSQL重启了辩论：如何最好地在数据库中表示多对多关系。那场辩论可比NoSQL古老得多，事实上，最早可以追溯到计算机化数据库系统。

20世纪70年代最受欢迎的业务数据处理数据库是IBM的信息管理系统（IMS），最初是为了阿波罗太空计划的库存管理而开发的，并于1968年有了首次商业发布。目前它仍在使用和维护，运行在IBM大型机的OS/390上。

IMS的设计中使用了一个相当简单的数据模型，称为层次模型（hierarchical model），它与文档数据库使用的JSON模型有一些惊人的相似之处。它将所有数据表示为嵌套在记录中的记录树，这很像JSON结构。

同文档数据库一样，IMS能良好处理一对多的关系，但是很难应对多对多的关系，并且不支持连接。开发人员必须决定是否复制（非规范化）数据或手动解决从一个记录到另一个记录的引用。这些二十世纪六七十年代的问题与现在开发人员遇到的文档数据库问题非常相似。

那时人们提出了各种不同的解决方案来解决层次模型的局限性。其中最突出的两个是关系模型（relational model）（它变成了SQL，统治了世界）和网络模型（network model）（最初很受关注，但最终变得冷门）。这两个阵营之间的“大辩论”在70年代持续了很久时间。

### 图模型

如我们之前所见，多对多关系是不同数据模型之间具有区别性的重要特征。如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。

但是，要是多对多关系在你的数据中很常见呢？关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。

一个图由两种对象组成：顶点（vertices）（也称为节点（nodes） 或实体（entities）），和边（edges）（ 也称为关系（relationships）或弧 （arcs） ）。多种数据可以被建模为一个图形。典型的例子包括：
* 社交图谱
  
    顶点是人，边指示哪些人彼此认识。
* 网络图谱
 
    顶点是网页，边缘表示指向其他页面的HTML链接。
* 公路或铁路网络
  
    顶点是交叉路口，边线代表它们之间的道路或铁路线。

可以将那些众所周知的算法运用到这些图上：例如，汽车导航系统搜索道路网络中两点之间的最短路径，PageRank可以用在网络图上来确定网页的流行程度，从而确定该网页在搜索结果中的排名。

在刚刚给出的例子中，图中的所有顶点代表了相同类型的事物（人，网页或交叉路口）。不过，图并不局限于这样的同类数据：同样强大地是，图提供了一种一致的方式，用来在单个数据存储中存储完全不同类型的对象。例如，Facebook维护一个包含许多不同类型的顶点和边的单个图：顶点表示人，地点，事件，签到和用户的评论;边缘表示哪些人是彼此的朋友，哪个签到发生在何处，谁评论了哪条消息，谁参与了哪个事件，等等。

### 时序数据模型

似乎直接搜索时序数据模型，是得不到和数据库方面相关的数据模型的介绍的，这里这样将其提出，也是为了与当前业界非常流行的时序数据库相匹配。

时序数据主要就是指按时间维度产生和索引的一些数据。 

>对时序数据进行建模的话，会包含三个重要部分，分别是：主体，时间点和测量值。套用这套模型，你会发现你在日常工作生活中，无时无刻不在接触着这类数据。
> - 如果你是一个股民，某只股票的股价就是一类时序数据，其记录着每个时间点该股票的股价。
> - 如果你是一个运维人员，监控数据是一类时序数据，例如对于机器的CPU的监控数据，就是记录着每个时间点机器上CPU的实际消耗值。 

因为有着对大量时序数据的存储和分析需求，为了解决传统关系型数据库在时序数据存储和分析上的不足和缺陷，一系列时序数据库产品便被创造出来。

能力水平有限，这里我就不细细的全部说明。
主要内容多参考自知乎专栏[NoSQL技术解析][NoSQL技术解析] 中的
《[时间序列数据的存储和计算 - 概述][时间序列数据的存储和计算 - 概述]》等系列文章。



[NoSQL技术解析]: https://zhuanlan.zhihu.com/nosql
[时间序列数据的存储和计算 - 概述]: https://zhuanlan.zhihu.com/p/32709932


## 比较和关联

接下来的内容会以一些例子来带大家思考这些模型在生产环境中的使用，来回穿插数据模型的内容。

### 关系和文档

#### 模型相关

![linkedln1](./imgs/linkedln1.png)

上图展示了如何用关系模式来表示个人信息（一个Linkedln简介）。

当我们在考虑数据库的设计的时候往往是这样的。
- 整个简介可以通过一个唯一的标识符`user_id`来标识
- `first_name` 和 `last_name` 这样的一些字段每个用户只出现一次，所以将其存储在 `user` 表中，建模为列。
- 大多数人在职业生涯中拥有多余一份的工作，有着不同样的教育阶段和任意数量的联系信息。这样的数据存在一些显然的一对多的关系，可以采用多种方式来表示：
  - 传统的SQL模型，将职位、教育、联系信息等数据存放在单独的表中，对User表提供外键引用。就像上图中所展示的一样。
  - 许多关系型数据库已经提供了对于结构化数据类型和XML数据的支持，允许将多值数据存储在单行内，并支持这种文档内部的查询和索引。（PostgreSQL中支持的对 [JSON][pg_json] 和 [Arrays][pg_arrays] 等数据的支持，MySQL从5.7.8版本也开始支持 JSON 数据）
  - 直接将职业、教育信息、联系数据这些编码为 JSON 或 XML 文档，将其存储在数据库的文本列中，并让应用程序解析其结构和内容，这种配置下，通常不能直接用数据库对该编码中的数值进行查询。
- 确认了一对多的数据存储形式后，建表并存储在db里，通过程序语言查询并转换为完整的对象。
  
  但是这个由关系表-》对象的过程，需要一个笨拙的转换层来实现（因为应用程序代码之中的对象和表，列，行的数据库模型之间存在着一些不匹配的地方，模型之间的不连贯有时被称为**[阻抗不匹配（impedance mismatch）][impedance_mismatch]**），对象关系映射（object-relational mapping, ORM）框架可以减少这样查询后转换层代码的数量，但是不能完全隐藏这两个模型之间的差异。

对于像个人介绍这样的自包含文档的数据结构而言，JSON 表示是非常合适的。JSON 比 XML 更简单。面向文档的数据库（ [MongoDB][mongodb]、[RethinkDB][rethinkdb] 等等）支持这样的数据类型。下方展示了如何用 JSON 文档表示一个 Linkedln 简介
```
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ],
  "education": [
    {
      "school_name": "Harvard University",
      "start": 1973,
      "end": 1975
    },
    {
      "school_name": "Lakeside School, Seattle",
      "start": null,
      "end": null
    }
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates" 
  }
}
```
从某些角度上来看，JSON 模型减少了应用程序代码和存储层之间的阻抗不匹配。但是 JSON 本身作为数据编码的格式也存在一些小问题（如不能区分整数浮点数，不能指定精度等问题）。与关系型的示例相比，可以避免关系型的多个查询（userid查询每个表），多表连接等问题。单次查询即可获得所有的相关信息。

在上述的例子中，这样的一对多关系隐含了数据中的一个树状结构，而 JSON 使得这个树状结构变得更加明确。如下图。

![树状结构图](./imgs/linkedln_tree.png)

这样看来似乎实质上文档模型这样的结构也就只是层次模型的另一种表示形式，我也有着类似的感受，故上面关于关系模型的描述中，我将有关层次模型的介绍放在了文档模型的一个子目录中。

以上的场景并不复杂，有时候又会有新的需求添加进来，比如个人的学校、公司等其实不是一个固定的名称之类，而是一个真实存在的实体，比如我们要给每个人添加一个推荐他人（有点类似对他人的点赞）的功能，同时需要能关联所推荐者和被推荐者的主页。前一个便成了每个人到实体的关联，后一个便成了每个人和多个人的多对多关联关系。

下图展示了这样的新功能拓展出的引用结构。
![multi_multi](./imgs/multi_multi.png)

关系型模型似乎非常便于解决这样的多对多关联问题。但是对于文档模型这样的解决方式似乎并不简便。上文中有关[层次模型](#层次模型)介绍的地方已经有所说明。

[pg_json]: https://www.postgresql.org/docs/11/datatype-json.html
[pg_arrays]: https://www.postgresql.org/docs/11/arrays.html
[impedance_mismatch]:https://baike.baidu.com/item/%E9%98%BB%E6%8A%97%E4%B8%8D%E5%8C%B9%E9%85%8D/5352021?fr=aladdin
[mongodb]: https://docs.mongodb.com/
[rethinkdb]: https://rethinkdb.com/docs/

#### MySQL 和 MongoDB

因为上面已经提到了这两种模型的一些关系和对比，所以我在这里列出两个最具代表性的对应数据库来阐述一些使用场景相关的东西。

以下内容较多参考自 惨绿少年 《[MongoDB 入门篇][mongo_door]》，可以直接阅读获得更多相关的知识内容。

看看两个数据库默认存储引擎的特性对比吧  

Name|MySQL InnoDB| MongoDB WiredTiger |  
-|-|-
事务|YES|YES(4.0+)|
GIS|YES(5.7.4+)|YES|
MVCC|YES|NO|
Replication|YES|YES|
ForeignKey|YES|NO| 
Full Text |YES|YES|
B-Tree Index| YES|YES|
Table Storage Limit|64TB|NO| 
表分区| YES|YES|

看起来其实 MongoDB 的一些特性并不如 MySQL 或者其他的 RDBMS 来的多，但是它提供了更多的架构灵活性和可拓展性。

再看看使用场景呢，MongoDB 更适用以下的场景：
- 数据量非常大，并且需要不断的扩容
- 读写性能要求较高
- 需求可能多次发生变化，数据模型无法发生变化。
- 高可用，低延迟
- 大量的地理位置查询
- 等等

但是这些场景是不是就该考虑其他数据库了呢：
- 大规模的持久化数据分析工作
- 任意字段的搜索和排序要求
- ERP，CRM等多对象关联的复杂运用
- 远程事务，跨文档事务等多事务操作
- 等等

[mongo_door]: https://www.cnblogs.com/clsn/p/8214194.html#auto_id_0

### 图和时序

以上所说的模型或数据库是我们非常常见或者说常用的一些思考，而数据库发展过程中遇到的问题非常多。不断产生着新的需求和产品，图数据库和时序数据库或许就是我们并不常见和了解的东西。

#### 图

尝试一下用关系表来表示属性图
```
CREATE TABLE vertices (
  vertex_id  INTEGER PRIMARY KEY,
  properties JSON
);

CREATE TABLE edges (
  edge_id     INTEGER PRIMARY KEY,
  tail_vertex INTEGER REFERENCES vertices (vertex_id),
  head_vertex INTEGER REFERENCES vertices (vertex_id),
  label       TEXT,
  properties  JSON
);

CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
```

似乎关系模型也可以表示这样的一个图结构。

但是我们要考虑关于这个模型的一些重要方面是：
1. 任何顶点都可以有一条边连接到任何其他顶点。没有模式限制哪种事物可不可以关联。
2. 给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动。（这就是为什么tail_vertex和head_vertex列上都有索引的原因。）
3. 通过对不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息，同时仍然保持一个清晰的数据模型。

考虑一下下图这样的关系~

![graph](./imgs/graph_eg.png)

图中显示了一些传统关系模式难以表达的事情，例如不同国家的不同地区结构（法国有省和州，美国有不同的州和州），国中国的怪事（先忽略主权国家和国家错综复杂的烂摊子），不同的数据粒度（Lucy现在的住所被指定为一个城市，而她的出生地点只是在一个州的级别）。

你可以想象延伸图还能包括许多关于Lucy和Alain，或其他人的其他更多的事实。例如，你可以用它来表示食物过敏（为每个过敏源增加一个顶点，并增加人与过敏源之间的一条边来指示一种过敏情况），并链接到过敏源，每个过敏源具有一组顶点用来显示哪些食物含有哪些物质。然后，你可以写一个查询，找出每个人吃什么是安全的。图表在可演化性是富有优势的：当向应用程序添加功能时，可以轻松扩展图以适应应用程序数据结构的变化。

不同的数据模式或者数据类型会让我们需要使用不同的查询语言来表达，标准SQL 就不太适合属性图中的关系查询，便有了类似 Cypher 这样的 [Neo4j][Neo4j] 专用的声明式查询语言。而传统的按行存储的数据格式在这里似乎也没法使用。

能力有限，细节的东西在这里我也不展开叙述，下一次分享中可能会探讨一些这方面的内容。

[Neo4j]: https://neo4j.com/

#### 时序

时序数据库常常出现在 IOT，股市等环境下。
这类的数据有这样的一些特点：
- 数据量大，类似物联网场景下监控数据等类型的数据，数据量非常大。
- 冷热分明，查询和分析多按时间范围进行（历史数据被查询的概率低于新数据）。
- 具有时效性，时间越久的数据可利用价值越低。
- 多精度数据存储（有的地方需要高精度，有的场景高精度反而无意义）。

上文[时序数据模型](#时序数据模型)中也描述了时序数据的一些特点，这里也就不多介绍了，参考上文中给出的链接。


## 总结
数据模型是一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。我们没有足够的空间来详细介绍每个模型的细节，但是希望这个概述足以激起你的兴趣，以更多地了解最适合你的应用需求的模型。

在历史上，数据最开始被表示为一棵大树（层次数据模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型“NoSQL”数据存储在两个主要方向上存在分歧：

- 文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。
- 图形数据库用于相反的场景：任意事物都可能与任何事物相关联。
  
这三种模型（文档，关系和图形）在今天都被广泛使用，并且在各自的领域都发挥很好。一个模型可以用另一个模型来模拟 — 例如，图数据可以在关系数据库中表示 — 但结果往往是糟糕的。这就是为什么我们有着针对不同目的的不同系统，而不是一个单一的万能解决方案。

文档数据库和图数据库有一个共同点，那就是它们通常不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。但是应用程序很可能仍会假定数据具有一定的结构；这只是模式是明确的（写入时强制）还是隐含的（读取时处理）的问题。

数据模型的不同引出不同的数据库，关系型数据库已经被业界广泛应用并不断扩展，NoSQL 也在这样的环境下飞速发展

总结一些代表性的数据库共大家参考：

|存储类型|数据库|
-|-
关系型| PostgreSQL、MySQL、SQLServer
K/V | Redis、Memcached、Cassandra、Rocksdb
文档| MongoDB、CouchDB、Terrastore
图 | Neo4j、InfiniteGraph、FlockDB
时序 | InfluxDB、OpenTSDB、KairosDB
列式存储|Hbase、ClickHouse、Cassandra

总之，百花齐放的数据库产品，各有优劣，没有最好的，只有最合适的，全凭你自己对业务需求的判断来做出选择。


## 参考文献
- [Designing Data-Intensive Application][DDIA]
- [MongoDB 入门篇][mongo_door]
- [时间序列数据的存储和计算 - 概述][时间序列数据的存储和计算 - 概述]

本文参考了许多其他的文章和书籍，其中基本都在文中列了出来，我做了一些修改和调整，也有一部分自己的总结，感谢这些分享的大佬们。